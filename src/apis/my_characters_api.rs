/*
 * Artifacts API
 *
 *  Artifacts is an API-based MMO game where you can manage 5 characters to explore, fight, gather resources, craft items and much more.  Website: https://artifactsmmo.com/  Documentation: https://docs.artifactsmmo.com/  OpenAPI Spec: https://api.artifactsmmo.com/openapi.json
 *
 * The version of the OpenAPI document: 1.6
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for passing parameters to the method [`accept_new_task`]
#[derive(Clone, Debug)]
pub struct AcceptNewTaskParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`complete_task`]
#[derive(Clone, Debug)]
pub struct CompleteTaskParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`craft`]
#[derive(Clone, Debug)]
pub struct CraftParams {
    /// Name of your character.
    pub name: String,
    pub crafting_schema: models::CraftingSchema,
}

/// struct for passing parameters to the method [`delete_item`]
#[derive(Clone, Debug)]
pub struct DeleteItemParams {
    /// Name of your character.
    pub name: String,
    pub simple_item_schema: models::SimpleItemSchema,
}

/// struct for passing parameters to the method [`deposit_gold`]
#[derive(Clone, Debug)]
pub struct DepositGoldParams {
    /// Name of your character.
    pub name: String,
    pub deposit_withdraw_gold_schema: models::DepositWithdrawGoldSchema,
}

/// struct for passing parameters to the method [`deposit_item`]
#[derive(Clone, Debug)]
pub struct DepositItemParams {
    /// Name of your character.
    pub name: String,
    pub simple_item_schema: models::SimpleItemSchema,
}

/// struct for passing parameters to the method [`equip_item`]
#[derive(Clone, Debug)]
pub struct EquipItemParams {
    /// Name of your character.
    pub name: String,
    pub equip_schema: models::EquipSchema,
}

/// struct for passing parameters to the method [`fight`]
#[derive(Clone, Debug)]
pub struct FightParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`gather`]
#[derive(Clone, Debug)]
pub struct GatherParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`ge_buy_item`]
#[derive(Clone, Debug)]
pub struct GeBuyItemParams {
    /// Name of your character.
    pub name: String,
    pub ge_transaction_item_schema: models::GeTransactionItemSchema,
}

/// struct for passing parameters to the method [`ge_sell_item`]
#[derive(Clone, Debug)]
pub struct GeSellItemParams {
    /// Name of your character.
    pub name: String,
    pub ge_transaction_item_schema: models::GeTransactionItemSchema,
}

/// struct for passing parameters to the method [`get_all_characters_logs`]
#[derive(Clone, Debug)]
pub struct GetAllCharactersLogsParams {
    /// Page number
    pub page: Option<u32>,
    /// Page size
    pub size: Option<u32>,
}

/// struct for passing parameters to the method [`move_character`]
#[derive(Clone, Debug)]
pub struct MoveCharacterParams {
    /// Name of your character.
    pub name: String,
    pub destination_schema: models::DestinationSchema,
}

/// struct for passing parameters to the method [`recycle`]
#[derive(Clone, Debug)]
pub struct RecycleParams {
    /// Name of your character.
    pub name: String,
    pub recycling_schema: models::RecyclingSchema,
}

/// struct for passing parameters to the method [`task_exchange`]
#[derive(Clone, Debug)]
pub struct TaskExchangeParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`unequip_item`]
#[derive(Clone, Debug)]
pub struct UnequipItemParams {
    /// Name of your character.
    pub name: String,
    pub unequip_schema: models::UnequipSchema,
}

/// struct for passing parameters to the method [`withdraw_gold`]
#[derive(Clone, Debug)]
pub struct WithdrawGoldParams {
    /// Name of your character.
    pub name: String,
    pub deposit_withdraw_gold_schema: models::DepositWithdrawGoldSchema,
}

/// struct for passing parameters to the method [`withdraw_item`]
#[derive(Clone, Debug)]
pub struct WithdrawItemParams {
    /// Name of your character.
    pub name: String,
    pub simple_item_schema: models::SimpleItemSchema,
}

/// struct for typed errors of method [`accept_new_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AcceptNewTaskError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Tasks Master not found on this map.
    Status598(),
    /// Character already has a task.
    Status489(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteTaskError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Tasks Master not found on this map.
    Status598(),
    /// Character has not completed the task.
    Status488(),
    /// Character has no task.
    Status487(),
    /// Character inventory is full.
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`craft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CraftError {
    /// Craft not found.
    Status404(),
    /// Workshop not found on this map.
    Status598(),
    /// Character not found.
    Status498(),
    /// Character inventory is full.
    Status497(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Not skill level required.
    Status493(),
    /// Missing item or insufficient quantity in your inventory.
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteItemError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Missing item or insufficient quantity in your inventory.
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`deposit_gold`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DepositGoldError {
    /// Bank not found on this map.
    Status598(),
    /// Insufficient golds on your character.
    Status492(),
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// A transaction is already in progress with this item/your golds in your bank.
    Status461(),
    /// An action is already in progress by your character.
    Status486(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`deposit_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DepositItemError {
    /// Bank not found on this map.
    Status598(),
    /// Item not found.
    Status404(),
    /// A transaction is already in progress with this item/your golds in your bank.
    Status461(),
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Missing item or insufficient quantity in your inventory.
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`equip_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EquipItemError {
    /// Item not found.
    Status404(),
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Missing item or insufficient quantity in your inventory.
    Status478(),
    /// Character level is insufficient.
    Status496(),
    /// Slot is not empty.
    Status491(),
    /// This item is already equipped.
    Status485(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fight`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FightError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// Monster not found on this map.
    Status598(),
    /// An action is already in progress by your character.
    Status486(),
    /// Character inventory is full.
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gather`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GatherError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// Resource not found on this map.
    Status598(),
    /// An action is already in progress by your character.
    Status486(),
    /// Not skill level required.
    Status493(),
    /// Character inventory is full.
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ge_buy_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeBuyItemError {
    /// Grand Exchange not found on this map.
    Status598(),
    /// Character not found.
    Status498(),
    /// Character inventory is full.
    Status497(),
    /// Character in cooldown.
    Status499(),
    /// A transaction is already in progress on this item by a another character.
    Status483(),
    /// An action is already in progress by your character.
    Status486(),
    /// Insufficient golds on your character.
    Status492(),
    /// No stock for this item.
    Status480(),
    /// No item at this price.
    Status482(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ge_sell_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeSellItemError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// Item not found.
    Status404(),
    /// A transaction is already in progress on this item by a another character.
    Status483(),
    /// An action is already in progress by your character.
    Status486(),
    /// Missing item or insufficient quantity in your inventory.
    Status478(),
    /// No item at this price.
    Status482(),
    /// Grand Exchange not found on this map.
    Status598(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_characters_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllCharactersLogsError {
    /// Logs not found.
    Status404(),
    /// Character not found.
    Status498(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_characters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyCharactersError {
    /// Characters not found.
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_character`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveCharacterError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// Character already at destination.
    Status490(),
    /// Map not found.
    Status404(),
    /// An action is already in progress by your character.
    Status486(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recycle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecycleError {
    /// Item not found.
    Status404(),
    /// Workshop not found on this map.
    Status598(),
    /// Character not found.
    Status498(),
    /// Character inventory is full.
    Status497(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Not skill level required.
    Status493(),
    /// Missing item or insufficient quantity in your inventory.
    Status478(),
    /// This item cannot be recycled.
    Status473(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`task_exchange`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TaskExchangeError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Tasks Master not found on this map.
    Status598(),
    /// Missing item or insufficient quantity in your inventory.
    Status478(),
    /// Character inventory is full.
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unequip_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnequipItemError {
    /// Item not found.
    Status404(),
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// An action is already in progress by your character.
    Status486(),
    /// Slot is empty.
    Status491(),
    /// Character inventory is full.
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`withdraw_gold`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WithdrawGoldError {
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// A transaction is already in progress with this item/your golds in your bank.
    Status461(),
    /// An action is already in progress by your character.
    Status486(),
    /// Bank not found on this map.
    Status598(),
    /// Insufficient golds in your bank.
    Status460(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`withdraw_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WithdrawItemError {
    /// Item not found.
    Status404(),
    /// Character not found.
    Status498(),
    /// Character in cooldown.
    Status499(),
    /// A transaction is already in progress with this item/your golds in your bank.
    Status461(),
    /// An action is already in progress by your character.
    Status486(),
    /// Character inventory is full.
    Status497(),
    /// Bank not found on this map.
    Status598(),
    /// Missing item or insufficient quantity in your inventory.
    Status478(),
    UnknownValue(serde_json::Value),
}

/// Accepting a new task.
pub async fn accept_new_task(
    configuration: &configuration::Configuration,
    params: AcceptNewTaskParams,
) -> Result<models::TaskResponseSchema, Error<AcceptNewTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/task/new",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AcceptNewTaskError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Complete a task.
pub async fn complete_task(
    configuration: &configuration::Configuration,
    params: CompleteTaskParams,
) -> Result<models::TaskRewardResponseSchema, Error<CompleteTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/task/complete",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CompleteTaskError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Crafting an item. The character must be on a map with a workshop.
pub async fn craft(
    configuration: &configuration::Configuration,
    params: CraftParams,
) -> Result<models::SkillResponseSchema, Error<CraftError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let crafting_schema = params.crafting_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/crafting",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&crafting_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CraftError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an item from your character's inventory.
pub async fn delete_item(
    configuration: &configuration::Configuration,
    params: DeleteItemParams,
) -> Result<models::DeleteItemResponseSchema, Error<DeleteItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let simple_item_schema = params.simple_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/delete",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&simple_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteItemError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deposit golds in a bank on the character's map.
pub async fn deposit_gold(
    configuration: &configuration::Configuration,
    params: DepositGoldParams,
) -> Result<models::GoldResponseSchema, Error<DepositGoldError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let deposit_withdraw_gold_schema = params.deposit_withdraw_gold_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/bank/deposit/gold",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&deposit_withdraw_gold_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DepositGoldError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deposit an item in a bank on the character's map.
pub async fn deposit_item(
    configuration: &configuration::Configuration,
    params: DepositItemParams,
) -> Result<models::ActionItemBankResponseSchema, Error<DepositItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let simple_item_schema = params.simple_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/bank/deposit",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&simple_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DepositItemError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Equip an item on your character.
pub async fn equip_item(
    configuration: &configuration::Configuration,
    params: EquipItemParams,
) -> Result<models::EquipmentResponseSchema, Error<EquipItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let equip_schema = params.equip_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/equip",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&equip_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EquipItemError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Start a fight against a monster on the character's map.
pub async fn fight(
    configuration: &configuration::Configuration,
    params: FightParams,
) -> Result<models::CharacterFightResponseSchema, Error<FightError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/fight",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FightError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Harvest a resource on the character's map.
pub async fn gather(
    configuration: &configuration::Configuration,
    params: GatherParams,
) -> Result<models::SkillResponseSchema, Error<GatherError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/gathering",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GatherError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Buy an item at the Grand Exchange on the character's map.
pub async fn ge_buy_item(
    configuration: &configuration::Configuration,
    params: GeBuyItemParams,
) -> Result<models::GeTransactionResponseSchema, Error<GeBuyItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let ge_transaction_item_schema = params.ge_transaction_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/ge/buy",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&ge_transaction_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GeBuyItemError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sell an item at the Grand Exchange on the character's map.
pub async fn ge_sell_item(
    configuration: &configuration::Configuration,
    params: GeSellItemParams,
) -> Result<models::GeTransactionResponseSchema, Error<GeSellItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let ge_transaction_item_schema = params.ge_transaction_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/ge/sell",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&ge_transaction_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GeSellItemError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// History of the last 100 actions of all your characters.
pub async fn get_all_characters_logs(
    configuration: &configuration::Configuration,
    params: GetAllCharactersLogsParams,
) -> Result<models::DataPageLogSchema, Error<GetAllCharactersLogsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page = params.page;
    let size = params.size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/my/logs", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = size {
        local_var_req_builder =
            local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllCharactersLogsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List of your characters.
pub async fn get_my_characters(
    configuration: &configuration::Configuration,
) -> Result<models::MyCharactersListSchema, Error<GetMyCharactersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/my/characters", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMyCharactersError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Moves a character on the map using the map's X and Y position.
pub async fn move_character(
    configuration: &configuration::Configuration,
    params: MoveCharacterParams,
) -> Result<models::CharacterMovementResponseSchema, Error<MoveCharacterError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let destination_schema = params.destination_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/move",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&destination_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MoveCharacterError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).
pub async fn recycle(
    configuration: &configuration::Configuration,
    params: RecycleParams,
) -> Result<models::RecyclingResponseSchema, Error<RecycleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let recycling_schema = params.recycling_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/recycling",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&recycling_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RecycleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.
pub async fn task_exchange(
    configuration: &configuration::Configuration,
    params: TaskExchangeParams,
) -> Result<models::TaskRewardResponseSchema, Error<TaskExchangeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/task/exchange",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TaskExchangeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unequip an item on your character.
pub async fn unequip_item(
    configuration: &configuration::Configuration,
    params: UnequipItemParams,
) -> Result<models::EquipmentResponseSchema, Error<UnequipItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let unequip_schema = params.unequip_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/unequip",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&unequip_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UnequipItemError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Withdraw gold from your bank.
pub async fn withdraw_gold(
    configuration: &configuration::Configuration,
    params: WithdrawGoldParams,
) -> Result<models::GoldResponseSchema, Error<WithdrawGoldError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let deposit_withdraw_gold_schema = params.deposit_withdraw_gold_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/bank/withdraw/gold",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&deposit_withdraw_gold_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<WithdrawGoldError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Take an item from your bank and put it in the character's inventory.
pub async fn withdraw_item(
    configuration: &configuration::Configuration,
    params: WithdrawItemParams,
) -> Result<models::ActionItemBankResponseSchema, Error<WithdrawItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let simple_item_schema = params.simple_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/bank/withdraw",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&simple_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<WithdrawItemError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
