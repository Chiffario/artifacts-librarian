/*
 * Artifacts API
 *
 *  Artifacts is an API-based MMO game where you can manage 5 characters to explore, fight, gather resources, craft items and much more.  Website: https://artifactsmmo.com/  Documentation: https://docs.artifactsmmo.com/  OpenAPI Spec: https://api.artifactsmmo.com/openapi.json
 *
 * The version of the OpenAPI document: 1.6
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for passing parameters to the method [`action_accept_new_task_my_name_action_task_new_post`]
#[derive(Clone, Debug)]
pub struct ActionAcceptNewTaskMyNameActionTaskNewPostParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`action_complete_task_my_name_action_task_complete_post`]
#[derive(Clone, Debug)]
pub struct ActionCompleteTaskMyNameActionTaskCompletePostParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`action_crafting_my_name_action_crafting_post`]
#[derive(Clone, Debug)]
pub struct ActionCraftingMyNameActionCraftingPostParams {
    /// Name of your character.
    pub name: String,
    pub crafting_schema: models::CraftingSchema,
}

/// struct for passing parameters to the method [`action_delete_item_my_name_action_delete_post`]
#[derive(Clone, Debug)]
pub struct ActionDeleteItemMyNameActionDeletePostParams {
    /// Name of your character.
    pub name: String,
    pub simple_item_schema: models::SimpleItemSchema,
}

/// struct for passing parameters to the method [`action_deposit_bank_gold_my_name_action_bank_deposit_gold_post`]
#[derive(Clone, Debug)]
pub struct ActionDepositBankGoldMyNameActionBankDepositGoldPostParams {
    /// Name of your character.
    pub name: String,
    pub deposit_withdraw_gold_schema: models::DepositWithdrawGoldSchema,
}

/// struct for passing parameters to the method [`action_deposit_bank_my_name_action_bank_deposit_post`]
#[derive(Clone, Debug)]
pub struct ActionDepositBankMyNameActionBankDepositPostParams {
    /// Name of your character.
    pub name: String,
    pub simple_item_schema: models::SimpleItemSchema,
}

/// struct for passing parameters to the method [`action_equip_item_my_name_action_equip_post`]
#[derive(Clone, Debug)]
pub struct ActionEquipItemMyNameActionEquipPostParams {
    /// Name of your character.
    pub name: String,
    pub equip_schema: models::EquipSchema,
}

/// struct for passing parameters to the method [`action_fight_my_name_action_fight_post`]
#[derive(Clone, Debug)]
pub struct ActionFightMyNameActionFightPostParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`action_gathering_my_name_action_gathering_post`]
#[derive(Clone, Debug)]
pub struct ActionGatheringMyNameActionGatheringPostParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`action_ge_buy_item_my_name_action_ge_buy_post`]
#[derive(Clone, Debug)]
pub struct ActionGeBuyItemMyNameActionGeBuyPostParams {
    /// Name of your character.
    pub name: String,
    pub ge_transaction_item_schema: models::GeTransactionItemSchema,
}

/// struct for passing parameters to the method [`action_ge_sell_item_my_name_action_ge_sell_post`]
#[derive(Clone, Debug)]
pub struct ActionGeSellItemMyNameActionGeSellPostParams {
    /// Name of your character.
    pub name: String,
    pub ge_transaction_item_schema: models::GeTransactionItemSchema,
}

/// struct for passing parameters to the method [`action_move_my_name_action_move_post`]
#[derive(Clone, Debug)]
pub struct ActionMoveMyNameActionMovePostParams {
    /// Name of your character.
    pub name: String,
    pub destination_schema: models::DestinationSchema,
}

/// struct for passing parameters to the method [`action_recycling_my_name_action_recycling_post`]
#[derive(Clone, Debug)]
pub struct ActionRecyclingMyNameActionRecyclingPostParams {
    /// Name of your character.
    pub name: String,
    pub recycling_schema: models::RecyclingSchema,
}

/// struct for passing parameters to the method [`action_task_exchange_my_name_action_task_exchange_post`]
#[derive(Clone, Debug)]
pub struct ActionTaskExchangeMyNameActionTaskExchangePostParams {
    /// Name of your character.
    pub name: String,
}

/// struct for passing parameters to the method [`action_unequip_item_my_name_action_unequip_post`]
#[derive(Clone, Debug)]
pub struct ActionUnequipItemMyNameActionUnequipPostParams {
    /// Name of your character.
    pub name: String,
    pub unequip_schema: models::UnequipSchema,
}

/// struct for passing parameters to the method [`action_withdraw_bank_gold_my_name_action_bank_withdraw_gold_post`]
#[derive(Clone, Debug)]
pub struct ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostParams {
    /// Name of your character.
    pub name: String,
    pub deposit_withdraw_gold_schema: models::DepositWithdrawGoldSchema,
}

/// struct for passing parameters to the method [`action_withdraw_bank_my_name_action_bank_withdraw_post`]
#[derive(Clone, Debug)]
pub struct ActionWithdrawBankMyNameActionBankWithdrawPostParams {
    /// Name of your character.
    pub name: String,
    pub simple_item_schema: models::SimpleItemSchema,
}

/// struct for passing parameters to the method [`get_all_characters_logs_my_logs_get`]
#[derive(Clone, Debug)]
pub struct GetAllCharactersLogsMyLogsGetParams {
    /// Page number
    pub page: Option<u32>,
    /// Page size
    pub size: Option<u32>,
}

/// struct for typed errors of method [`action_accept_new_task_my_name_action_task_new_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionAcceptNewTaskMyNameActionTaskNewPostError {
    Status498(),
    Status499(),
    Status486(),
    Status598(),
    Status489(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_complete_task_my_name_action_task_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionCompleteTaskMyNameActionTaskCompletePostError {
    Status498(),
    Status499(),
    Status486(),
    Status598(),
    Status488(),
    Status487(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_crafting_my_name_action_crafting_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionCraftingMyNameActionCraftingPostError {
    Status404(),
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status486(),
    Status493(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_delete_item_my_name_action_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDeleteItemMyNameActionDeletePostError {
    Status498(),
    Status499(),
    Status486(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_deposit_bank_gold_my_name_action_bank_deposit_gold_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDepositBankGoldMyNameActionBankDepositGoldPostError {
    Status598(),
    Status492(),
    Status498(),
    Status499(),
    Status461(),
    Status486(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_deposit_bank_my_name_action_bank_deposit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDepositBankMyNameActionBankDepositPostError {
    Status598(),
    Status404(),
    Status461(),
    Status498(),
    Status499(),
    Status486(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_equip_item_my_name_action_equip_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionEquipItemMyNameActionEquipPostError {
    Status404(),
    Status498(),
    Status499(),
    Status486(),
    Status478(),
    Status496(),
    Status491(),
    Status485(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_fight_my_name_action_fight_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionFightMyNameActionFightPostError {
    Status498(),
    Status499(),
    Status598(),
    Status486(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_gathering_my_name_action_gathering_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGatheringMyNameActionGatheringPostError {
    Status498(),
    Status499(),
    Status598(),
    Status486(),
    Status493(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_ge_buy_item_my_name_action_ge_buy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGeBuyItemMyNameActionGeBuyPostError {
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status483(),
    Status486(),
    Status492(),
    Status480(),
    Status482(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_ge_sell_item_my_name_action_ge_sell_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGeSellItemMyNameActionGeSellPostError {
    Status498(),
    Status499(),
    Status404(),
    Status483(),
    Status486(),
    Status478(),
    Status482(),
    Status598(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_move_my_name_action_move_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionMoveMyNameActionMovePostError {
    Status498(),
    Status499(),
    Status490(),
    Status404(),
    Status486(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_recycling_my_name_action_recycling_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionRecyclingMyNameActionRecyclingPostError {
    Status404(),
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status486(),
    Status493(),
    Status478(),
    Status473(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_task_exchange_my_name_action_task_exchange_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionTaskExchangeMyNameActionTaskExchangePostError {
    Status498(),
    Status499(),
    Status486(),
    Status598(),
    Status478(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_unequip_item_my_name_action_unequip_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionUnequipItemMyNameActionUnequipPostError {
    Status404(),
    Status498(),
    Status499(),
    Status486(),
    Status491(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_withdraw_bank_gold_my_name_action_bank_withdraw_gold_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError {
    Status498(),
    Status499(),
    Status461(),
    Status486(),
    Status598(),
    Status460(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_withdraw_bank_my_name_action_bank_withdraw_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionWithdrawBankMyNameActionBankWithdrawPostError {
    Status404(),
    Status498(),
    Status499(),
    Status461(),
    Status486(),
    Status497(),
    Status598(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_characters_logs_my_logs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllCharactersLogsMyLogsGetError {
    Status404(),
    Status498(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_characters_my_characters_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyCharactersMyCharactersGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Accepting a new task.
pub async fn action_accept_new_task_my_name_action_task_new_post(
    configuration: &configuration::Configuration,
    params: ActionAcceptNewTaskMyNameActionTaskNewPostParams,
) -> Result<models::TaskResponseSchema, Error<ActionAcceptNewTaskMyNameActionTaskNewPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/task/new",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionAcceptNewTaskMyNameActionTaskNewPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Complete a task.
pub async fn action_complete_task_my_name_action_task_complete_post(
    configuration: &configuration::Configuration,
    params: ActionCompleteTaskMyNameActionTaskCompletePostParams,
) -> Result<
    models::TaskRewardResponseSchema,
    Error<ActionCompleteTaskMyNameActionTaskCompletePostError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/task/complete",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionCompleteTaskMyNameActionTaskCompletePostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Crafting an item. The character must be on a map with a workshop.
pub async fn action_crafting_my_name_action_crafting_post(
    configuration: &configuration::Configuration,
    params: ActionCraftingMyNameActionCraftingPostParams,
) -> Result<models::SkillResponseSchema, Error<ActionCraftingMyNameActionCraftingPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let crafting_schema = params.crafting_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/crafting",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&crafting_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionCraftingMyNameActionCraftingPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an item from your character's inventory.
pub async fn action_delete_item_my_name_action_delete_post(
    configuration: &configuration::Configuration,
    params: ActionDeleteItemMyNameActionDeletePostParams,
) -> Result<models::DeleteItemResponseSchema, Error<ActionDeleteItemMyNameActionDeletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let simple_item_schema = params.simple_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/delete",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&simple_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionDeleteItemMyNameActionDeletePostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deposit golds in a bank on the character's map.
pub async fn action_deposit_bank_gold_my_name_action_bank_deposit_gold_post(
    configuration: &configuration::Configuration,
    params: ActionDepositBankGoldMyNameActionBankDepositGoldPostParams,
) -> Result<
    models::GoldResponseSchema,
    Error<ActionDepositBankGoldMyNameActionBankDepositGoldPostError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let deposit_withdraw_gold_schema = params.deposit_withdraw_gold_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/bank/deposit/gold",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&deposit_withdraw_gold_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionDepositBankGoldMyNameActionBankDepositGoldPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deposit an item in a bank on the character's map.
pub async fn action_deposit_bank_my_name_action_bank_deposit_post(
    configuration: &configuration::Configuration,
    params: ActionDepositBankMyNameActionBankDepositPostParams,
) -> Result<
    models::ActionItemBankResponseSchema,
    Error<ActionDepositBankMyNameActionBankDepositPostError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let simple_item_schema = params.simple_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/bank/deposit",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&simple_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionDepositBankMyNameActionBankDepositPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Equip an item on your character.
pub async fn action_equip_item_my_name_action_equip_post(
    configuration: &configuration::Configuration,
    params: ActionEquipItemMyNameActionEquipPostParams,
) -> Result<models::EquipmentResponseSchema, Error<ActionEquipItemMyNameActionEquipPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let equip_schema = params.equip_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/equip",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&equip_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionEquipItemMyNameActionEquipPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Start a fight against a monster on the character's map.
pub async fn action_fight_my_name_action_fight_post(
    configuration: &configuration::Configuration,
    params: ActionFightMyNameActionFightPostParams,
) -> Result<models::CharacterFightResponseSchema, Error<ActionFightMyNameActionFightPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/fight",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionFightMyNameActionFightPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Harvest a resource on the character's map.
pub async fn action_gathering_my_name_action_gathering_post(
    configuration: &configuration::Configuration,
    params: ActionGatheringMyNameActionGatheringPostParams,
) -> Result<models::SkillResponseSchema, Error<ActionGatheringMyNameActionGatheringPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/gathering",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionGatheringMyNameActionGatheringPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Buy an item at the Grand Exchange on the character's map.
pub async fn action_ge_buy_item_my_name_action_ge_buy_post(
    configuration: &configuration::Configuration,
    params: ActionGeBuyItemMyNameActionGeBuyPostParams,
) -> Result<models::GeTransactionResponseSchema, Error<ActionGeBuyItemMyNameActionGeBuyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let ge_transaction_item_schema = params.ge_transaction_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/ge/buy",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&ge_transaction_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionGeBuyItemMyNameActionGeBuyPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sell an item at the Grand Exchange on the character's map.
pub async fn action_ge_sell_item_my_name_action_ge_sell_post(
    configuration: &configuration::Configuration,
    params: ActionGeSellItemMyNameActionGeSellPostParams,
) -> Result<models::GeTransactionResponseSchema, Error<ActionGeSellItemMyNameActionGeSellPostError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let ge_transaction_item_schema = params.ge_transaction_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/ge/sell",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&ge_transaction_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionGeSellItemMyNameActionGeSellPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Moves a character on the map using the map's X and Y position.
pub async fn action_move_my_name_action_move_post(
    configuration: &configuration::Configuration,
    params: ActionMoveMyNameActionMovePostParams,
) -> Result<models::CharacterMovementResponseSchema, Error<ActionMoveMyNameActionMovePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let destination_schema = params.destination_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/move",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&destination_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionMoveMyNameActionMovePostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).
pub async fn action_recycling_my_name_action_recycling_post(
    configuration: &configuration::Configuration,
    params: ActionRecyclingMyNameActionRecyclingPostParams,
) -> Result<models::RecyclingResponseSchema, Error<ActionRecyclingMyNameActionRecyclingPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let recycling_schema = params.recycling_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/recycling",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&recycling_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionRecyclingMyNameActionRecyclingPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.
pub async fn action_task_exchange_my_name_action_task_exchange_post(
    configuration: &configuration::Configuration,
    params: ActionTaskExchangeMyNameActionTaskExchangePostParams,
) -> Result<
    models::TaskRewardResponseSchema,
    Error<ActionTaskExchangeMyNameActionTaskExchangePostError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/task/exchange",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionTaskExchangeMyNameActionTaskExchangePostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unequip an item on your character.
pub async fn action_unequip_item_my_name_action_unequip_post(
    configuration: &configuration::Configuration,
    params: ActionUnequipItemMyNameActionUnequipPostParams,
) -> Result<models::EquipmentResponseSchema, Error<ActionUnequipItemMyNameActionUnequipPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let unequip_schema = params.unequip_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/unequip",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&unequip_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionUnequipItemMyNameActionUnequipPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Withdraw gold from your bank.
pub async fn action_withdraw_bank_gold_my_name_action_bank_withdraw_gold_post(
    configuration: &configuration::Configuration,
    params: ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostParams,
) -> Result<
    models::GoldResponseSchema,
    Error<ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let deposit_withdraw_gold_schema = params.deposit_withdraw_gold_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/bank/withdraw/gold",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&deposit_withdraw_gold_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Take an item from your bank and put it in the character's inventory.
pub async fn action_withdraw_bank_my_name_action_bank_withdraw_post(
    configuration: &configuration::Configuration,
    params: ActionWithdrawBankMyNameActionBankWithdrawPostParams,
) -> Result<
    models::ActionItemBankResponseSchema,
    Error<ActionWithdrawBankMyNameActionBankWithdrawPostError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let simple_item_schema = params.simple_item_schema;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/my/{name}/action/bank/withdraw",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&simple_item_schema);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActionWithdrawBankMyNameActionBankWithdrawPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// History of the last 100 actions of all your characters.
pub async fn get_all_characters_logs_my_logs_get(
    configuration: &configuration::Configuration,
    params: GetAllCharactersLogsMyLogsGetParams,
) -> Result<models::DataPageLogSchema, Error<GetAllCharactersLogsMyLogsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page = params.page;
    let size = params.size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/my/logs", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = size {
        local_var_req_builder =
            local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllCharactersLogsMyLogsGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List of your characters.
pub async fn get_my_characters_my_characters_get(
    configuration: &configuration::Configuration,
) -> Result<models::MyCharactersListSchema, Error<GetMyCharactersMyCharactersGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/my/characters", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMyCharactersMyCharactersGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
